# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs_lib/models.utils.ipynb.

# %% auto 0
__all__ = []

# %% ../../nbs_lib/models.utils.ipynb 3
from .conv_rnn import *
from fastcore.all import *
from fastai.vision.all import Learner

# %% ../../nbs_lib/models.utils.ipynb 4
@patch
@delegates(Learner.get_preds)
def get_preds_iterative(self:Learner, dl, n_iter=1, track_losses=False, **kwargs):
    """
        Call get preds iteratively on a dataloader with a `DensityTupleTransform`
        TODO: Crashes if inner=True (kwargs), so it will produce invisible progress
        bars 
    """
    p, t = self.get_preds(dl=dl, **kwargs)
    ds_copy = copy(dl.ds) # Useful to move the gap without changing the original ds
    if track_losses:
        losses = [self.loss_func(p,t).item()]
    for _ in range(n_iter-1):
        ds_copy.data = ds_copy.data[:,ds_copy.h:] # Move h steps forward
        dl_new = dl.new(TfmdLists(range(len(ds_copy)), 
                                    DensityTupleTransform(ds_copy)))
        p,t = self.get_preds(dl=dl_new, **kwargs)
        if track_losses:
            losses.append(self.loss_func(p,t).item())
    if track_losses:
        return p, t, losses
    else:
        return p, t

# %% ../../nbs_lib/models.utils.ipynb 6
@patch
def get_individual_losses(self:Learner, p, t):
    """
        Get the loss for each element given predictions and targets computed
        in learn.get_preds
    """
    individual_losses = []
    for i in range(p[0].shape[0]):
        p_element = tuple(p_horizon[i] for p_horizon in p) 
        t_element = tuple(t_horizon[i] for t_horizon in t)
        loss = self.loss_func(p_element, t_element)
        individual_losses.append(loss)
    return tensor(individual_losses)
