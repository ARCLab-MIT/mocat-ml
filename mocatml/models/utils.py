# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs_lib/models.utils.ipynb.

# %% auto 0
__all__ = ['stack_density_list_as_preds_targs']

# %% ../../nbs_lib/models.utils.ipynb 3
from .conv_rnn import *
from ..data import *
from fastcore.all import *
from fastai.vision.all import *
from copy import copy

# %% ../../nbs_lib/models.utils.ipynb 4
def stack_density_list_as_preds_targs(l):
    all_preds = [x.to_preds_or_targs() for x in l]
    # Rearrange to get a list of 4 elements, each containing tensors of shape (10, 1, 36, 99)
    final_preds = []
    for seq_idx in range(len(l[0])):  # Assuming each DensitySeq has length 4
        # Collect the seq_idx-th prediction from each DensitySeq and stack them
        stack = torch.stack([preds[seq_idx].squeeze(0) for preds in all_preds], dim=0)
        final_preds.append(stack)
    return final_preds


# %% ../../nbs_lib/models.utils.ipynb 7
@patch
@delegates(Learner.get_preds, but=["with_input", "with_loss", "with_decoded"])
def get_preds_iterative(self:Learner, dl, n_iter=1, track_losses=False,
                        with_input=False, **kwargs):
    """
        Call get preds iteratively on a dataloader with a `DensityTupleTransform`
        TODO: Crashes if inner=True (kwargs), so it will produce invisible progress
        bars 
    """
    inp, p, t = self.get_preds(dl=dl, with_input=True, **kwargs)
    #ds_copy = copy(dl.ds) # Useful to move the gap without changing the original ds
    ds = dl.ds
    if track_losses:
        losses = [self.loss_func(p,t).item()]
    for iter in range(n_iter-1):
        data_copy = ds.data[:,(iter+1)*(ds.lbk+ds.gap):\
                                 (iter+1)*(ds.lbk+ds.gap) + ds.lbk + ds.h].copy()
        #ds_copy.data = ds_copy.data[:,(ds_copy.lbk+ds_copy.gap):] # Move 1 window forward
        ds_copy = DensityData(data_copy, lbk=ds.lbk, h=ds.h, gap=ds.gap)
        tl = TfmdLists(range(len(ds_copy)), DensityTupleTransform(ds_copy))
        # Save the targets before replacing data
        t = stack_density_list_as_preds_targs([y for _,y in tl])
        # Replace the first inputs of the dataset with the predictions
        p_dseqs = [DensitySeq.from_preds_or_targs(p, i, to_array=True) \
                   for i in range(len(p[0]))]
        preds_data = np.stack(p_dseqs).squeeze()
        ds_copy.data[:,:ds_copy.lbk] = preds_data
        dl_new = dl.new(TfmdLists(range(len(ds_copy)), 
                                  DensityTupleTransform(ds_copy)))
        p,_ = self.get_preds(dl=dl_new, with_input=False, **kwargs)
        if track_losses:
            losses.append(self.loss_func(p,t).item())
    res  = [p, t]
    if with_input: res = [inp] + res
    if track_losses: 
        losses = tensor(losses)
        res = res + [losses]
    return tuple(res)

# %% ../../nbs_lib/models.utils.ipynb 9
@patch
def get_individual_losses(self:Learner, p, t):
    """
        Get the loss for each element given predictions and targets computed
        in learn.get_preds
    """
    individual_losses = []
    for i in range(p[0].shape[0]):
        p_element = tuple(p_horizon[i] for p_horizon in p) 
        t_element = tuple(t_horizon[i] for t_horizon in t)
        loss = self.loss_func(p_element, t_element)
        individual_losses.append(loss)
    return tensor(individual_losses)

# %% ../../nbs_lib/models.utils.ipynb 11
@patch
def predict_at(self:Learner, idx, ds_idx=1, ds=None, with_input=False):
    """
        Predict at a given index on a given dataset, or in the learner's
    """
    ds = self.dls[ds_idx].ds if ds is None else ds
    tl = TfmdLists([idx], DensityTupleTransform(ds))
    dl = self.dls.new(tl)
    if with_input: 
        inp,p,t = self.get_preds(dl=dl, with_input=True, inner=True)
        return inp,p,t
    else:
        p, t = self.get_preds(dl=dl, with_input=False, inner=True)
        return p, t

# %% ../../nbs_lib/models.utils.ipynb 13
@patch
@delegates(DensitySeq.show, but=["title", "start_epoch"])
def show_preds_at(self:Learner, idx, p=None, t=None, inp=None, with_input=None, 
                  with_targets=False, titles=["Input", "Prediction", "Target"],
                  start_epoch=0, **kwargs):
    """
        Show predictions at a given index
    """
    if t is not None: with_targets=True
    if inp is not None: with_input=True
    if p is None:
        inp, p, t = self.predict_at(idx, with_input=True, **kwargs)
        idx = 0
    if with_input:
        i_seq = DensitySeq.create([inp[i][idx] for i in range(len(inp))])
        i_seq.show(title=titles[0], x_disc=RP_DISC, y_disc=AM_DISC, **kwargs)
    p_seq = DensitySeq.create([p[i][idx] for i in range(len(p))])
    p_seq.show(start_epoch=start_epoch+len(p), title=titles[1], 
               x_disc=RP_DISC, y_disc=AM_DISC, **kwargs)
    if with_targets:
        t_seq = DensitySeq.create([t[i][idx] for i in range(len(t))])
        t_seq.show(start_epoch=start_epoch+len(p), title=titles[2], 
                   x_disc=RP_DISC, y_disc=AM_DISC, **kwargs)
