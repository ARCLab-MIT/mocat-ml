# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs_lib/models.utils.ipynb.

# %% auto 0
__all__ = []

# %% ../../nbs_lib/models.utils.ipynb 3
from .conv_rnn import *
from ..data import *
from fastcore.all import *
from fastai.vision.all import Learner, tensor

# %% ../../nbs_lib/models.utils.ipynb 4
@patch
@delegates(Learner.get_preds)
def get_preds_iterative(self:Learner, dl, n_iter=1, track_losses=False, **kwargs):
    """
        Call get preds iteratively on a dataloader with a `DensityTupleTransform`
        TODO: Crashes if inner=True (kwargs), so it will produce invisible progress
        bars 
    """
    p, t = self.get_preds(dl=dl, **kwargs)
    ds_copy = copy(dl.ds) # Useful to move the gap without changing the original ds
    if track_losses:
        losses = [self.loss_func(p,t).item()]
    for _ in range(n_iter-1):
        ds_copy.data = ds_copy.data[:,ds_copy.h:] # Move h steps forward
        dl_new = dl.new(TfmdLists(range(len(ds_copy)), 
                                    DensityTupleTransform(ds_copy)))
        p,t = self.get_preds(dl=dl_new, **kwargs)
        if track_losses:
            losses.append(self.loss_func(p,t).item())
    if track_losses:
        return p, t, losses
    else:
        return p, t

# %% ../../nbs_lib/models.utils.ipynb 6
@patch
def get_individual_losses(self:Learner, p, t):
    """
        Get the loss for each element given predictions and targets computed
        in learn.get_preds
    """
    individual_losses = []
    for i in range(p[0].shape[0]):
        p_element = tuple(p_horizon[i] for p_horizon in p) 
        t_element = tuple(t_horizon[i] for t_horizon in t)
        loss = self.loss_func(p_element, t_element)
        individual_losses.append(loss)
    return tensor(individual_losses)

# %% ../../nbs_lib/models.utils.ipynb 8
@patch
def predict_at(self:Learner, idx, ds_idx=1, ds=None, with_input=False):
    """
        Predict at a given index on a given dataset, or in the learner's
    """
    ds = self.dls[ds_idx].ds if ds is None else ds
    tl = TfmdLists([idx], DensityTupleTransform(ds))
    dl = self.dls.new(tl)
    if with_input: 
        inp,p,t = self.get_preds(dl=dl, with_input=True, inner=True)
        return inp,p,t
    else:
        p, t = self.get_preds(dl=dl, with_input=False, inner=True)
        return p, t

# %% ../../nbs_lib/models.utils.ipynb 10
@patch
@delegates(Learner.predict_at)
def show_preds_at(self:Learner, idx, p=None, t=None, inp=None, with_input=None, 
                  with_targets=False, figsize=(5,3), **kwargs):
    """
        Show predictions at a given index
    """
    if t is not None: with_targets=True
    if inp is not None: with_input=True
    if p is None:
        inp, p, t = self.predict_at(idx, with_input=True, **kwargs)
        idx = 0
    if with_input:
        i_seq = DensitySeq.create([inp[i][idx] for i in range(len(inp))])
        i_seq.show(figsize=figsize, title="Input", x_disc=RP_DISC, y_disc=AM_DISC)
    p_seq = DensitySeq.create([p[i][idx] for i in range(len(p))])
    p_seq.show(figsize=figsize, start_epoch=len(p), title="Prediction", x_disc=RP_DISC, y_disc=AM_DISC)
    if with_targets:
        t_seq = DensitySeq.create([t[i][idx] for i in range(len(t))])
        t_seq.show(figsize=figsize, start_epoch=len(p), title="Target", x_disc=RP_DISC, y_disc=AM_DISC)
