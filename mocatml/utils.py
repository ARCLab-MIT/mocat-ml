# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs_lib/utils.ipynb.

# %% auto 0
__all__ = ['convert_uuids_to_indices', 'percent_rel_error_', 'apply_sliding_window_3d']

# %% ../nbs_lib/utils.ipynb 2
import os
import re
import numpy as np
from fastcore.all import *
from tsai.data.preparation import SlidingWindow

# %% ../nbs_lib/utils.ipynb 3
def convert_uuids_to_indices():
    cuda_visible_devices = os.environ.get("CUDA_VISIBLE_DEVICES", "")
    uuids = re.findall(r"\b[0-9a-fA-F]{8}(?:-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}\b", cuda_visible_devices)

    if uuids:
        indices = [str(i) for i in range(len(uuids))]
        os.environ["CUDA_VISIBLE_DEVICES"] = ",".join(indices)

# %% ../nbs_lib/utils.ipynb 4
def percent_rel_error_(N, N_mc, N_mc_t0):
    """
    Return the percentage relative error with respect to the MC simulation
    See Eq. 23 of the paper by Giudici et al. (2023), 'Space debris density 
    propagation through a vinite volume method'
    Input:
        N: Predicted number of in-orbit elements over time
        N_mc: Number of in-orbit elements from the MC simulation over time
        N_mc_t0: Number of in-orbit elements from the MC simulation at t0
    Output:
        The percentage relative error (float)
    """
    return 100 * np.abs(N_mc - N) / N_mc_t0

# %% ../nbs_lib/utils.ipynb 6
@delegates(SlidingWindow)
def apply_sliding_window_3d(data, window_len, **kwargs):
    """
        Apply sliding window to 3D data. The data is assumed to have the shape
        (n_samples, n_features, n_time_steps).
        Input:
            data: 3D array
            window_len: int, length of the sliding window
            horizon: int, number of time steps to predict
            kwargs: additional arguments to SlidingWindow
        Output:
            X: 3D array, shape (n_samples, n_features, window_len)
            y: 3D array, shape (n_samples, n_features, horizon)
    """
    sw = SlidingWindow(window_len=window_len, **kwargs)
    # Apply the sliding window to every sample (loop on dimension 0) of the data
    slices = [sw(x) for x in data]
    # Concatenate the slices into single arrays (X and y)
    X = np.concatenate([s[0] for s in slices])
    y = np.concatenate([s[1] for s in slices])
    # In case y is a 2D array (config.horizon = 1), add the time dimension at the end
    if y.ndim == 2:
        y = np.expand_dims(y, -1)
    return X, y
